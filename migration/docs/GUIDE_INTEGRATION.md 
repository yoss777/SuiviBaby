# ğŸš€ Guide d'IntÃ©gration - Migration Double Ã‰criture

## ğŸ“¦ Installation

### 1. Copier les fichiers dans ton projet

```
src/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ eventsService.ts                 âœ… Service unifiÃ©
â”‚   â”œâ”€â”€ eventsDoubleWriteService.ts     âœ… Double Ã©criture
â”‚   â”œâ”€â”€ eventsHybridService.ts          âœ… Lecture hybride
â”‚   â””â”€â”€ migrationScript.ts              âœ… Script migration
â”œâ”€â”€ contexts/
â”‚   â””â”€â”€ MigrationProvider.tsx           âœ… Context React
â””â”€â”€ components/
    â””â”€â”€ MigrationComponents.tsx         âœ… UI Components
```

### 2. Installer les dÃ©pendances

```bash
npm install @react-native-async-storage/async-storage
# ou
yarn add @react-native-async-storage/async-storage
```

---

## ğŸ”§ Configuration Initiale

### Ã‰tape 1: Wrapper ton App avec MigrationProvider

```tsx
// App.tsx
import { MigrationProvider } from './contexts/MigrationProvider';

export default function App() {
  return (
    <MigrationProvider>
      {/* Ton app existante */}
    </MigrationProvider>
  );
}
```

### Ã‰tape 2: CrÃ©er les Indexes Firestore

Va dans **Firebase Console > Firestore > Indexes** et crÃ©e ces 2 indexes :

```javascript
// Index 1: Pour queries avec type
{
  collection: "events",
  fields: [
    { field: "userId", order: "ASCENDING" },
    { field: "childId", order: "ASCENDING" },
    { field: "type", order: "ASCENDING" },
    { field: "date", order: "DESCENDING" }
  ]
}

// Index 2: Pour queries sans type
{
  collection: "events",
  fields: [
    { field: "userId", order: "ASCENDING" },
    { field: "childId", order: "ASCENDING" },
    { field: "date", order: "DESCENDING" }
  ]
}
```

---

## ğŸ“± Utilisation dans les Ã‰crans

### Exemple 1: Timeline UnifiÃ©e

```tsx
import { ecouterEvenements } from '../services/eventsService';
import { useMigration } from '../contexts/MigrationProvider';

function TimelineScreen() {
  const [events, setEvents] = useState([]);
  const { canUseNewFeatures } = useMigration();
  const childId = "child_123";

  useEffect(() => {
    const unsubscribe = ecouterEvenements(childId, setEvents);
    return unsubscribe;
  }, [childId]);

  return (
    <FlatList
      data={events}
      renderItem={({ item }) => <EventItem event={item} />}
    />
  );
}
```

### Exemple 2: Ã‰cran TÃ©tÃ©es avec Lecture Hybride

```tsx
import { 
  ajouterTetee, 
  ecouterTeteesHybrid 
} from '../services/eventsHybridService';

function TeteesScreen() {
  const [tetees, setTetees] = useState([]);
  const childId = "child_123";

  useEffect(() => {
    // Lecture hybride = merge OLD + NEW automatiquement
    const unsubscribe = ecouterTeteesHybrid(childId, setTetees);
    return unsubscribe;
  }, [childId]);

  const handleAjouter = async () => {
    // Double Ã©criture automatique (OLD + NEW)
    await ajouterTetee(childId, {
      coteGauche: true,
      coteDroit: true,
      dureeGauche: 10,
      dureeDroite: 8,
    });
  };

  return (
    <View>
      <Button title="Ajouter tÃ©tÃ©e" onPress={handleAjouter} />
      <FlatList data={tetees} {...} />
    </View>
  );
}
```

### Exemple 3: Ajouter une Couche avec DÃ©tails

```tsx
import { ajouterCoucheAvecDetails } from '../services/eventsService';

function ChangeCoucheButton() {
  const childId = "child_123";

  const handleCouchePipiPopo = async () => {
    // CrÃ©e 3 events : couche + miction + selle
    await ajouterCoucheAvecDetails(childId, {
      avecMiction: true,
      mictionDetails: { couleur: 'jaune' },
      avecSelle: true,
      selleDetails: { 
        consistance: 'molle',
        quantite: 'moyen',
      },
    });
  };

  return (
    <Button 
      title="ğŸ§·ğŸ’§ğŸ’© Couche Complete" 
      onPress={handleCouchePipiPopo} 
    />
  );
}
```

---

## ğŸ¯ Timeline de DÃ©ploiement

### **Jour 0: PrÃ©paration**

âœ… Copier tous les fichiers  
âœ… CrÃ©er les indexes Firestore  
âœ… Tester en dev sur un compte test  

```tsx
// Tester la migration sur un compte test
const { startMigration } = useMigration();
await startMigration(testUserId, testChildId);
```

---

### **Jour 1: DÃ©ploiement Production**

1. **DÃ©ployer l'app avec le MigrationProvider**
2. **Les utilisateurs voient la banniÃ¨re de migration**
3. **Ne rien forcer** - laisser les utilisateurs migrer quand ils veulent

```tsx
// HomeScreen.tsx
import { MigrationBanner } from '../components/MigrationComponents';

function HomeScreen() {
  return (
    <View>
      <MigrationBanner childId={childId} />
      {/* Reste de l'Ã©cran */}
    </View>
  );
}
```

---

### **Jours 2-7: Phase Double Ã‰criture**

Les utilisateurs qui ont migrÃ©:
- âœ… **Ã‰crivent** dans OLD + NEW
- âœ… **Lisent** depuis NEW (avec fallback sur OLD)
- âœ… Voient toutes leurs donnÃ©es

**Monitoring:**

```tsx
// Dans un Ã©cran admin ou settings
import { MigrationAdminScreen } from '../components/MigrationComponents';

function SettingsScreen() {
  return <MigrationAdminScreen childId={childId} />;
}
```

---

### **Jours 8-14: Validation**

VÃ©rifier que tout fonctionne:

```tsx
const { checkMigrationStatus } = useMigration();

// VÃ©rifier l'intÃ©gritÃ© des donnÃ©es
const status = await checkMigrationStatus(userId, childId);
console.log('Events migrÃ©s:', status.eventCount);
console.log('Anciennes collections:', status.oldCollectionsCount);
```

Si tout est OK, passer Ã  la phase suivante:

```tsx
const { advanceToNextPhase } = useMigration();
await advanceToNextPhase(); // DOUBLE_WRITE â†’ VALIDATION
```

---

### **Jour 15+: Migration ComplÃ¨te**

```tsx
await advanceToNextPhase(); // VALIDATION â†’ COMPLETE
```

Ã€ partir de maintenant:
- âœ… Ã‰criture **uniquement** dans NEW
- âœ… Lecture **uniquement** depuis NEW
- âœ… Anciennes collections peuvent Ãªtre supprimÃ©es (aprÃ¨s 1 mois)

---

## ğŸš¨ En Cas de ProblÃ¨me

### Rollback ImmÃ©diat

```tsx
const { rollbackToOldSystem } = useMigration();

// Revenir Ã  l'ancien systÃ¨me en 1 clic
rollbackToOldSystem();
```

**Effet:**
- â®ï¸ Retour Ã  OLD_ONLY
- âœ… Aucune perte de donnÃ©es (OLD existe toujours)
- âœ… App fonctionne comme avant

---

### Debug: Voir la source des donnÃ©es

Pendant la phase hybride, chaque event a un champ `_source`:

```tsx
function EventItem({ event }) {
  return (
    <View>
      <Text>{event.type}</Text>
      {/* Debug: voir d'oÃ¹ vient l'event */}
      {event._source && (
        <Text style={{ fontSize: 10 }}>
          Source: {event._source} {/* OLD ou NEW */}
        </Text>
      )}
    </View>
  );
}
```

---

## ğŸ“Š Dashboard de Migration

Ajouter un Ã©cran admin pour suivre la progression:

```tsx
import { MigrationAdminScreen } from '../components/MigrationComponents';

function AdminMigrationScreen() {
  const childId = "child_123";
  
  return (
    <ScrollView>
      <MigrationAdminScreen childId={childId} />
    </ScrollView>
  );
}
```

**FonctionnalitÃ©s:**
- ğŸ“ˆ Statut de la phase actuelle
- ğŸ” VÃ©rifier l'intÃ©gritÃ© des donnÃ©es
- â¡ï¸ Avancer Ã  la phase suivante
- âš ï¸ Rollback si nÃ©cessaire
- ğŸ“Š Statistiques de migration

---

## ğŸ¨ Personnalisation de la BanniÃ¨re

```tsx
// Dans ton HomeScreen
import { MigrationBanner } from '../components/MigrationComponents';

function HomeScreen() {
  return (
    <View>
      {/* BanniÃ¨re auto-cachÃ©e si pas nÃ©cessaire */}
      <MigrationBanner childId={childId} />
      
      {/* Ton contenu */}
    </View>
  );
}
```

La banniÃ¨re s'affiche automatiquement si:
- Phase = NOT_STARTED (propose de migrer)
- Phase = DOUBLE_WRITE (confirme la migration)

---

## ğŸ”§ Configuration AvancÃ©e

### Changer la fenÃªtre de dÃ©duplication

```tsx
import { setHybridConfig } from '../services/eventsHybridService';

// Par dÃ©faut: 5 secondes
// 2 events Ã  moins de 5s d'Ã©cart = considÃ©rÃ©s comme doublons

setHybridConfig({
  deduplicationWindow: 10000, // 10 secondes
});
```

### PrÃ©fÃ©rer OLD en cas de doublon

```tsx
setHybridConfig({
  preferSource: 'OLD', // Au lieu de 'NEW'
});
```

### Forcer Ã©chec si OLD Ã©choue

```tsx
import { setMigrationConfig } from '../services/eventsDoubleWriteService';

setMigrationConfig({
  failOnError: true, // Stopper si OLD Ã©choue
});
```

---

## âœ… Checklist de DÃ©ploiement

### Avant le DÃ©ploiement
- [ ] Indexes Firestore crÃ©Ã©s
- [ ] Tests sur compte de dev
- [ ] MigrationProvider installÃ©
- [ ] BanniÃ¨re ajoutÃ©e Ã  HomeScreen
- [ ] Backup des anciennes collections fait

### AprÃ¨s le DÃ©ploiement
- [ ] Suivre les premiÃ¨res migrations (logs)
- [ ] VÃ©rifier les statistiques (MigrationAdminScreen)
- [ ] Surveiller Firebase Console (reads/writes)
- [ ] Collecter feedback utilisateurs

### AprÃ¨s 7 jours
- [ ] Comparer stats OLD vs NEW
- [ ] VÃ©rifier intÃ©gritÃ© des donnÃ©es
- [ ] Avancer phase si tout OK

### AprÃ¨s 30 jours
- [ ] Phase COMPLETE pour tous
- [ ] Supprimer anciennes collections
- [ ] Supprimer ancien code
- [ ] CÃ©lÃ©brer ! ğŸ‰

---

## ğŸ†˜ Support

### ProblÃ¨mes FrÃ©quents

**Q: La migration Ã©choue avec "index not found"**  
R: VÃ©rifie que les indexes Firestore sont crÃ©Ã©s et actifs

**Q: Je vois des doublons dans la timeline**  
R: Augmente `deduplicationWindow` ou vÃ©rifie que les timestamps sont cohÃ©rents

**Q: L'app est plus lente aprÃ¨s migration**  
R: Normal pendant DOUBLE_WRITE (2x d'Ã©critures). Ã‡a s'amÃ©liore en COMPLETE.

**Q: Comment annuler une migration ?**  
R: Utilise `rollbackToOldSystem()` - aucune perte de donnÃ©es

---

## ğŸ“ Besoin d'Aide ?

1. Check les logs console (beaucoup d'infos de debug)
2. VÃ©rifie Firebase Console > Firestore > Usage
3. Utilise MigrationAdminScreen pour diagnostiquer
4. En dernier recours: rollback

---

## ğŸ‰ RÃ©sultat Final

Une fois la migration COMPLETE:
- âš¡ **90% moins de listeners Firestore**
- ğŸ’° **70% de rÃ©duction des coÃ»ts**
- ğŸš€ **Timeline instantanÃ©e**
- ğŸ§¹ **Code 60% plus court**
- âœ¨ **PrÃªt pour les nouvelles features**

Temps total: **5-7 jours de dev + 2-4 semaines de transition**